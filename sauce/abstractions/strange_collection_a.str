false &&
{	strange :
	{	<collection> :: abstraction
		(	// dimensions
			#key :<<>># <>,
			#value :<<>># <>,
			#element :<<>># <>,
			(	// parent
				$$<range>[ #element ],
				{	// collection
					has_ :# (key :< #key >#, <>),
					has : "bool (_key const& key) const { return has_(key); }",

					at_ :# (key :< #key >#, < #value >),

					update_ := (key :< #key >#, value :< #value >#, < #value >),
					update : "void (_key const& key, _value const& value) { update_(key, value); }",

					insert_ := (key :< #key >#, value :< #value >#, <>),
					insert : "void (_key const& key, _value const& value) { insert_(key, value); }",

					erase_ := (key :< #key >#, <>),
					erase : "bool (_key const& key) { return erase_(key); }",

					clear_ := (<collection[< #key >, < #value >, < #element >]>),
					clear : "void () { clear_(); }",

					size_ :# (<number_data_int64>),
					size : "int64_t () const { return size_().extract_primitive(); }",

					empty_ :# (<>),
					empty : "bool () const { return empty_(); }",

					push_front_ := (thing :< #element >#, <collection[< #key >, < #value >, < #element >]>),
					push_front : "void (_element const& thing) { push_front_(thing); }",

					pop_front_ := (< #element >),

					push_back_ := (thing :< #element >#, <collection[< #key >, < #value >, < #element >]>),
					push_back : "void (_element const& thing) { push_back_(thing); }",

					pop_back_ := (<#element>),

					self_assign_ := (range :<range[< #element >]>#, <collection[< #key >, < #value >, < #element >]>),

					self_add_ := (range :<range[< #element >]>#, <collection[< #key >, < #value >, < #element >]>),

					add_ :# (range :<range[< #element >]>#, <collection[< #key >, < #value >, < #element >]>),

					self_subtract_ := (range :<range[< #element >]>#, <collection[< #key >, < #value >, < #element >]>),

					subtract_ :# (range :<range[< #element >]>#, <collection[< #key >, < #value >, < #element >]>),

					read_lock_ :# (<>),

					write_lock_ :# (<>),
				}
			)
		)
	}
}