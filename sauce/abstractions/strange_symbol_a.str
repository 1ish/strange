false &&
{	strange :
	{	<symbol> :: abstraction
		(	// no dimensions
			(	// parent
				$$<>[],
				{	// symbol
					'operator==' : "bool (symbol_a<> const& symbol) const { return same_(symbol); }",
					'operator!=' : "bool (symbol_a<> const& symbol) const { return different_(symbol); }",
					'operator<' : "bool (symbol_a<> const& symbol) const { return less_than_(symbol); }",
					'operator>' : "bool (symbol_a<> const& symbol) const { return greater_than_(symbol); }",
					'operator<=' : "bool (symbol_a<> const& symbol) const { return less_or_equal_(symbol); }",
					'operator>=' : "bool (symbol_a<> const& symbol) const { return greater_or_equal_(symbol); }",

					to_lake_ :# (<lake_int8>),
					to_string : "std_string () const { return lake::to_string(to_lake_()); }",
					to_c_string : "char const* () const { return to_string().c_str(); }",

					first_character : "int8_t () const { return to_lake_().extract_vector()[0]; }",
					last_character : "int8_t () const { auto const lake = to_lake_(); return lake.extract_vector()[lake.size() - 1]; }",

					add_ :# (symbol :<symbol>#, <symbol>),
				}
			)
		)
	}
}