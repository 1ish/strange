
namespace strange
{

template <typename _1 = void>
class container_d;

template <typename _1 = void>
inline container_d<_1> ___container_dynamic___(any_a<> const& thing);

template <typename _1>
class container_a : public collection_a< any_a<> , container_a<> , container_a<> >
{
public:
	inline any_a<> unpack__(list_a<> const& ___arguments___) const;

	inline any_a<> unpack_(shoal_a<> const& shared_shoal) const;

	inline any_a<> unpack_unique__(list_a<> const& ___arguments___) const;

	inline any_a<> unpack_unique_(shoal_a<> const& shared_shoal, shoal_a<number_data_uint64_a<>, strange::any_a<>> & unique_shoal) const;

	inline any_a < > unpack(shoal_a < > const & shared_shoal , any_a < > & unique_shoal ) const;

	inline any_a<> close__(list_a<> const& ___arguments___);

	inline any_a<> close_();

	inline bool close();

	inline any_a<> closed__(list_a<> const& ___arguments___) const;

	inline any_a<> closed_() const;

	inline bool closed() const;

	inline any_a<> reopen__(list_a<> const& ___arguments___);

	inline any_a<> reopen_();

	inline bool reopen();

	inline any_a<> from_json__(list_a<> const& ___arguments___);

	inline container_a<> from_json_(lake_int8_a<> const& lake);

	inline void from_json(std_string const & str );

	inline any_a<> to_json__(list_a<> const& ___arguments___) const;

	inline lake_int8_a<> to_json_() const;

	inline std_string to_json() const;

	inline any_a<> from_binary__(list_a<> const& ___arguments___);

	inline container_a<> from_binary_(lake_int8_a<> const& lake);

	inline void from_binary(std_string const & str );

	inline any_a<> to_binary__(list_a<> const& ___arguments___) const;

	inline lake_int8_a<> to_binary_() const;

	inline std_string to_binary() const;

	inline any_a<> from_null__(list_a<> const& ___arguments___);

	inline container_a<> from_null_();

	inline void from_null();

	inline any_a<> is_null__(list_a<> const& ___arguments___) const;

	inline any_a<> is_null_() const;

	inline bool is_null() const;

	inline any_a<> from_boolean__(list_a<> const& ___arguments___);

	inline container_a<> from_boolean_(any_a<> const& boolean);

	inline void from_boolean(bool boolean );

	inline any_a<> is_boolean__(list_a<> const& ___arguments___) const;

	inline any_a<> is_boolean_() const;

	inline bool is_boolean() const;

	inline any_a<> to_boolean__(list_a<> const& ___arguments___) const;

	inline any_a<> to_boolean_() const;

	inline bool to_boolean() const;

	inline any_a<> from_number__(list_a<> const& ___arguments___);

	inline container_a<> from_number_(number_a<> const& number);

	inline void from_number(number_a < > const & number );

	inline any_a<> is_number__(list_a<> const& ___arguments___) const;

	inline any_a<> is_number_() const;

	inline bool is_number() const;

	inline any_a<> to_number__(list_a<> const& ___arguments___) const;

	inline number_a<> to_number_() const;

	inline any_a<> from_int_64__(list_a<> const& ___arguments___);

	inline container_a<> from_int_64_(number_data_int64_a<> const& number);

	inline void from_int_64(int64_t number );

	inline any_a<> is_int_64__(list_a<> const& ___arguments___) const;

	inline any_a<> is_int_64_() const;

	inline bool is_int_64() const;

	inline any_a<> to_int_64__(list_a<> const& ___arguments___) const;

	inline number_data_int64_a<> to_int_64_() const;

	inline int64_t to_int_64() const;

	inline any_a<> from_float_64__(list_a<> const& ___arguments___);

	inline container_a<> from_float_64_(number_data_double_a<> const& number);

	inline void from_float_64(double number );

	inline any_a<> is_float_64__(list_a<> const& ___arguments___) const;

	inline any_a<> is_float_64_() const;

	inline bool is_float_64() const;

	inline any_a<> to_float_64__(list_a<> const& ___arguments___) const;

	inline number_data_double_a<> to_float_64_() const;

	inline double to_float_64() const;

	inline any_a<> from_lake__(list_a<> const& ___arguments___);

	inline container_a<> from_lake_(lake_int8_a<> const& lake);

	inline void from_lake(lake_int8_a < > const & lake );

	inline void from_string(std_string const & str );

	inline any_a<> is_lake__(list_a<> const& ___arguments___) const;

	inline any_a<> is_lake_() const;

	inline bool is_lake() const;

	inline any_a<> to_lake__(list_a<> const& ___arguments___) const;

	inline lake_int8_a<> to_lake_() const;

	inline std_string to_string() const;

	inline any_a<> from_symbol__(list_a<> const& ___arguments___);

	inline container_a<> from_symbol_(symbol_a<> const& symbol);

	inline void from_symbol(symbol_a < > const & symbol );

	inline any_a<> to_symbol__(list_a<> const& ___arguments___) const;

	inline symbol_a<> to_symbol_() const;

	inline any_a<> make_inventory__(list_a<> const& ___arguments___);

	inline container_a<> make_inventory_();

	inline void make_inventory();

	inline any_a<> from_inventory__(list_a<> const& ___arguments___);

	inline container_a<> from_inventory_(inventory_a<container_a<>> const& inventory);

	inline void from_inventory(inventory_a < container_a < > > const & inventory );

	inline any_a<> is_inventory__(list_a<> const& ___arguments___) const;

	inline any_a<> is_inventory_() const;

	inline bool is_inventory() const;

	inline any_a<> as_inventory__(list_a<> const& ___arguments___) const;

	inline any_a<> as_inventory_(inventory_a<container_a<>> & inventory) const;

	inline void as_inventory(inventory_a < container_a < > > & inventory ) const;

	inline any_a<> make_herd__(list_a<> const& ___arguments___);

	inline container_a<> make_herd_();

	inline void make_herd();

	inline any_a<> from_herd__(list_a<> const& ___arguments___);

	inline container_a<> from_herd_(herd_a<symbol_a<>> const& herd);

	inline void from_herd(herd_a < symbol_a < > > const & herd );

	inline any_a<> is_herd__(list_a<> const& ___arguments___) const;

	inline any_a<> is_herd_() const;

	inline bool is_herd() const;

	inline any_a<> as_herd__(list_a<> const& ___arguments___) const;

	inline any_a<> as_herd_(herd_a<symbol_a<>> & herd) const;

	inline void as_herd(herd_a < symbol_a < > > & herd ) const;

	inline any_a<> make_shoal__(list_a<> const& ___arguments___);

	inline container_a<> make_shoal_();

	inline void make_shoal();

	inline any_a<> from_shoal__(list_a<> const& ___arguments___);

	inline container_a<> from_shoal_(shoal_a<symbol_a<>, container_a<>> const& shoal);

	inline void from_shoal(shoal_a < symbol_a < > , container_a < > > const & shoal );

	inline any_a<> is_shoal__(list_a<> const& ___arguments___) const;

	inline any_a<> is_shoal_() const;

	inline bool is_shoal() const;

	inline any_a<> as_shoal__(list_a<> const& ___arguments___) const;

	inline any_a<> as_shoal_(shoal_a<symbol_a<>, container_a<>> & shoal) const;

	inline void as_shoal(shoal_a < symbol_a < > , container_a < > > & shoal ) const;

	inline any_a<> from_data__(list_a<> const& ___arguments___);

	inline any_a<> from_data_(any_a<> const& data);

	inline bool from_data(any_a < > const & data );

	inline any_a<> as_data__(list_a<> const& ___arguments___) const;

	inline any_a<> as_data_(any_a<> & data) const;

	inline bool as_data(any_a < > & data ) const;

	inline any_a<> keys_begin__(list_a<> const& ___arguments___) const;

	inline bidirectional_extractor_a< any_a<> > keys_begin_() const;

	inline any_a<> keys_end__(list_a<> const& ___arguments___) const;

	inline bidirectional_extractor_a< any_a<> > keys_end_() const;

protected:
	struct ___container_a_handle_base___ : collection_a< any_a<> , container_a<> , container_a<> >::___collection_a_handle_base___
	{
		virtual any_a<> unpack_(shoal_a<> const& shared_shoal) const = 0;
		virtual any_a<> unpack_unique_(shoal_a<> const& shared_shoal, shoal_a<number_data_uint64_a<>, strange::any_a<>> & unique_shoal) const = 0;
		virtual any_a < > unpack(shoal_a < > const & shared_shoal , any_a < > & unique_shoal ) const = 0;
		virtual any_a<> close_() = 0;
		virtual bool close() = 0;
		virtual any_a<> closed_() const = 0;
		virtual bool closed() const = 0;
		virtual any_a<> reopen_() = 0;
		virtual bool reopen() = 0;
		virtual container_a<> from_json_(lake_int8_a<> const& lake) = 0;
		virtual void from_json(std_string const & str ) = 0;
		virtual lake_int8_a<> to_json_() const = 0;
		virtual std_string to_json() const = 0;
		virtual container_a<> from_binary_(lake_int8_a<> const& lake) = 0;
		virtual void from_binary(std_string const & str ) = 0;
		virtual lake_int8_a<> to_binary_() const = 0;
		virtual std_string to_binary() const = 0;
		virtual container_a<> from_null_() = 0;
		virtual void from_null() = 0;
		virtual any_a<> is_null_() const = 0;
		virtual bool is_null() const = 0;
		virtual container_a<> from_boolean_(any_a<> const& boolean) = 0;
		virtual void from_boolean(bool boolean ) = 0;
		virtual any_a<> is_boolean_() const = 0;
		virtual bool is_boolean() const = 0;
		virtual any_a<> to_boolean_() const = 0;
		virtual bool to_boolean() const = 0;
		virtual container_a<> from_number_(number_a<> const& number) = 0;
		virtual void from_number(number_a < > const & number ) = 0;
		virtual any_a<> is_number_() const = 0;
		virtual bool is_number() const = 0;
		virtual number_a<> to_number_() const = 0;
		virtual container_a<> from_int_64_(number_data_int64_a<> const& number) = 0;
		virtual void from_int_64(int64_t number ) = 0;
		virtual any_a<> is_int_64_() const = 0;
		virtual bool is_int_64() const = 0;
		virtual number_data_int64_a<> to_int_64_() const = 0;
		virtual int64_t to_int_64() const = 0;
		virtual container_a<> from_float_64_(number_data_double_a<> const& number) = 0;
		virtual void from_float_64(double number ) = 0;
		virtual any_a<> is_float_64_() const = 0;
		virtual bool is_float_64() const = 0;
		virtual number_data_double_a<> to_float_64_() const = 0;
		virtual double to_float_64() const = 0;
		virtual container_a<> from_lake_(lake_int8_a<> const& lake) = 0;
		virtual void from_lake(lake_int8_a < > const & lake ) = 0;
		virtual void from_string(std_string const & str ) = 0;
		virtual any_a<> is_lake_() const = 0;
		virtual bool is_lake() const = 0;
		virtual lake_int8_a<> to_lake_() const = 0;
		virtual std_string to_string() const = 0;
		virtual container_a<> from_symbol_(symbol_a<> const& symbol) = 0;
		virtual void from_symbol(symbol_a < > const & symbol ) = 0;
		virtual symbol_a<> to_symbol_() const = 0;
		virtual container_a<> make_inventory_() = 0;
		virtual void make_inventory() = 0;
		virtual container_a<> from_inventory_(inventory_a<container_a<>> const& inventory) = 0;
		virtual void from_inventory(inventory_a < container_a < > > const & inventory ) = 0;
		virtual any_a<> is_inventory_() const = 0;
		virtual bool is_inventory() const = 0;
		virtual any_a<> as_inventory_(inventory_a<container_a<>> & inventory) const = 0;
		virtual void as_inventory(inventory_a < container_a < > > & inventory ) const = 0;
		virtual container_a<> make_herd_() = 0;
		virtual void make_herd() = 0;
		virtual container_a<> from_herd_(herd_a<symbol_a<>> const& herd) = 0;
		virtual void from_herd(herd_a < symbol_a < > > const & herd ) = 0;
		virtual any_a<> is_herd_() const = 0;
		virtual bool is_herd() const = 0;
		virtual any_a<> as_herd_(herd_a<symbol_a<>> & herd) const = 0;
		virtual void as_herd(herd_a < symbol_a < > > & herd ) const = 0;
		virtual container_a<> make_shoal_() = 0;
		virtual void make_shoal() = 0;
		virtual container_a<> from_shoal_(shoal_a<symbol_a<>, container_a<>> const& shoal) = 0;
		virtual void from_shoal(shoal_a < symbol_a < > , container_a < > > const & shoal ) = 0;
		virtual any_a<> is_shoal_() const = 0;
		virtual bool is_shoal() const = 0;
		virtual any_a<> as_shoal_(shoal_a<symbol_a<>, container_a<>> & shoal) const = 0;
		virtual void as_shoal(shoal_a < symbol_a < > , container_a < > > & shoal ) const = 0;
		virtual any_a<> from_data_(any_a<> const& data) = 0;
		virtual bool from_data(any_a < > const & data ) = 0;
		virtual any_a<> as_data_(any_a<> & data) const = 0;
		virtual bool as_data(any_a < > & data ) const = 0;
		virtual bidirectional_extractor_a< any_a<> > keys_begin_() const = 0;
		virtual bidirectional_extractor_a< any_a<> > keys_end_() const = 0;
	};

	template <typename ___TTT___, typename ___DHB___ = ___container_a_handle_base___>
	struct ___container_a_handle___ : collection_a< any_a<> , container_a<> , container_a<> >::template ___collection_a_handle___<___TTT___, ___DHB___>
	{
		template <typename ___UUU___ = ___TTT___>
		inline ___container_a_handle___(___TTT___ value, typename std::enable_if_t<std::is_reference<___UUU___>::value>* = 0)
			: collection_a< any_a<> , container_a<> , container_a<> >::template ___collection_a_handle___<___TTT___, ___DHB___>{ value }
		{}

		template <typename ___UUU___ = ___TTT___>
		inline ___container_a_handle___(___TTT___ value, typename std::enable_if_t<!std::is_reference<___UUU___>::value, int>* = 0) noexcept
			: collection_a< any_a<> , container_a<> , container_a<> >::template ___collection_a_handle___<___TTT___, ___DHB___>{ std::move(value) }
		{}

		template <typename... Args>
		inline ___container_a_handle___(any_a<>::___variadic_tag___, Args&&... args)
			: collection_a< any_a<> , container_a<> , container_a<> >::template ___collection_a_handle___<___TTT___, ___DHB___>(any_a<>::___variadic_tag___{}, std::forward<Args>(args)...)
		{}

		virtual inline any_a<> unpack_(shoal_a<> const& shared_shoal) const final;

		virtual inline any_a<> unpack_unique_(shoal_a<> const& shared_shoal, shoal_a<number_data_uint64_a<>, strange::any_a<>> & unique_shoal) const final;

		virtual inline any_a < > unpack(shoal_a < > const & shared_shoal , any_a < > & unique_shoal ) const final;

		virtual inline any_a<> close_() final;

		virtual inline bool close() final;

		virtual inline any_a<> closed_() const final;

		virtual inline bool closed() const final;

		virtual inline any_a<> reopen_() final;

		virtual inline bool reopen() final;

		virtual inline container_a<> from_json_(lake_int8_a<> const& lake) final;

		virtual inline void from_json(std_string const & str ) final;

		virtual inline lake_int8_a<> to_json_() const final;

		virtual inline std_string to_json() const final;

		virtual inline container_a<> from_binary_(lake_int8_a<> const& lake) final;

		virtual inline void from_binary(std_string const & str ) final;

		virtual inline lake_int8_a<> to_binary_() const final;

		virtual inline std_string to_binary() const final;

		virtual inline container_a<> from_null_() final;

		virtual inline void from_null() final;

		virtual inline any_a<> is_null_() const final;

		virtual inline bool is_null() const final;

		virtual inline container_a<> from_boolean_(any_a<> const& boolean) final;

		virtual inline void from_boolean(bool boolean ) final;

		virtual inline any_a<> is_boolean_() const final;

		virtual inline bool is_boolean() const final;

		virtual inline any_a<> to_boolean_() const final;

		virtual inline bool to_boolean() const final;

		virtual inline container_a<> from_number_(number_a<> const& number) final;

		virtual inline void from_number(number_a < > const & number ) final;

		virtual inline any_a<> is_number_() const final;

		virtual inline bool is_number() const final;

		virtual inline number_a<> to_number_() const final;

		virtual inline container_a<> from_int_64_(number_data_int64_a<> const& number) final;

		virtual inline void from_int_64(int64_t number ) final;

		virtual inline any_a<> is_int_64_() const final;

		virtual inline bool is_int_64() const final;

		virtual inline number_data_int64_a<> to_int_64_() const final;

		virtual inline int64_t to_int_64() const final;

		virtual inline container_a<> from_float_64_(number_data_double_a<> const& number) final;

		virtual inline void from_float_64(double number ) final;

		virtual inline any_a<> is_float_64_() const final;

		virtual inline bool is_float_64() const final;

		virtual inline number_data_double_a<> to_float_64_() const final;

		virtual inline double to_float_64() const final;

		virtual inline container_a<> from_lake_(lake_int8_a<> const& lake) final;

		virtual inline void from_lake(lake_int8_a < > const & lake ) final;

		virtual inline void from_string(std_string const & str ) final;

		virtual inline any_a<> is_lake_() const final;

		virtual inline bool is_lake() const final;

		virtual inline lake_int8_a<> to_lake_() const final;

		virtual inline std_string to_string() const final;

		virtual inline container_a<> from_symbol_(symbol_a<> const& symbol) final;

		virtual inline void from_symbol(symbol_a < > const & symbol ) final;

		virtual inline symbol_a<> to_symbol_() const final;

		virtual inline container_a<> make_inventory_() final;

		virtual inline void make_inventory() final;

		virtual inline container_a<> from_inventory_(inventory_a<container_a<>> const& inventory) final;

		virtual inline void from_inventory(inventory_a < container_a < > > const & inventory ) final;

		virtual inline any_a<> is_inventory_() const final;

		virtual inline bool is_inventory() const final;

		virtual inline any_a<> as_inventory_(inventory_a<container_a<>> & inventory) const final;

		virtual inline void as_inventory(inventory_a < container_a < > > & inventory ) const final;

		virtual inline container_a<> make_herd_() final;

		virtual inline void make_herd() final;

		virtual inline container_a<> from_herd_(herd_a<symbol_a<>> const& herd) final;

		virtual inline void from_herd(herd_a < symbol_a < > > const & herd ) final;

		virtual inline any_a<> is_herd_() const final;

		virtual inline bool is_herd() const final;

		virtual inline any_a<> as_herd_(herd_a<symbol_a<>> & herd) const final;

		virtual inline void as_herd(herd_a < symbol_a < > > & herd ) const final;

		virtual inline container_a<> make_shoal_() final;

		virtual inline void make_shoal() final;

		virtual inline container_a<> from_shoal_(shoal_a<symbol_a<>, container_a<>> const& shoal) final;

		virtual inline void from_shoal(shoal_a < symbol_a < > , container_a < > > const & shoal ) final;

		virtual inline any_a<> is_shoal_() const final;

		virtual inline bool is_shoal() const final;

		virtual inline any_a<> as_shoal_(shoal_a<symbol_a<>, container_a<>> & shoal) const final;

		virtual inline void as_shoal(shoal_a < symbol_a < > , container_a < > > & shoal ) const final;

		virtual inline any_a<> from_data_(any_a<> const& data) final;

		virtual inline bool from_data(any_a < > const & data ) final;

		virtual inline any_a<> as_data_(any_a<> & data) const final;

		virtual inline bool as_data(any_a < > & data ) const final;

		virtual inline bidirectional_extractor_a< any_a<> > keys_begin_() const final;

		virtual inline bidirectional_extractor_a< any_a<> > keys_end_() const final;

	};

	template <typename ___TTT___, typename ___DHB___>
	struct ___container_a_handle___<std::reference_wrapper<___TTT___>, ___DHB___>
		: ___container_a_handle___<___TTT___&, ___DHB___>
	{
		inline ___container_a_handle___(std::reference_wrapper<___TTT___> ref)
			: ___container_a_handle___<___TTT___&, ___DHB___>{ ref.get() }
		{}
	};

private:
	template <typename ___TTT___>
	struct ___container_a_handle_final___ final : ___container_a_handle___<___TTT___>
	{
		template <typename ___UUU___ = ___TTT___>
		inline ___container_a_handle_final___(___TTT___ value, typename std::enable_if_t<std::is_reference<___UUU___>::value>* = 0)
			: ___container_a_handle___<___TTT___>{ value }
		{}

		template <typename ___UUU___ = ___TTT___>
		inline ___container_a_handle_final___(___TTT___ value, typename std::enable_if_t<!std::is_reference<___UUU___>::value, int>* = 0) noexcept
			: ___container_a_handle___<___TTT___>{ std::move(value) }
		{}

		template <typename... Args>
		inline ___container_a_handle_final___(any_a<>::___variadic_tag___, Args&&... args)
			: ___container_a_handle___<___TTT___>(any_a<>::___variadic_tag___{}, std::forward<Args>(args)...)
		{}

		virtual inline any_a<>::___SHARED___ ___clone___() const final
		{
			return std_make_shared<___container_a_handle_final___>(___container_a_handle___<___TTT___>::___value___);
		}
	};

	template <typename ___TTT___>
	struct ___container_a_handle_final___<std::reference_wrapper<___TTT___>> final
		: ___container_a_handle_final___<___TTT___&>
	{
		inline ___container_a_handle_final___(std::reference_wrapper<___TTT___> ref)
			: ___container_a_handle_final___<___TTT___&>{ ref.get() }
		{}
	};

protected:
	inline ___container_a_handle_base___ const& ___read___() const noexcept
	{
		return *std::static_pointer_cast<___container_a_handle_base___ const>(any_a<>::___handle___);
	}

	inline ___container_a_handle_base___& ___write___() noexcept
	{
		if (!any_a<>::___handle___.unique())
		{
			any_a<>::___handle___ = any_a<>::___handle___->___clone___();
			any_a<>::___handle___->___weak___(any_a<>::___handle___);
		}
		return *std::static_pointer_cast<___container_a_handle_base___>(any_a<>::___handle___);
	}

public:
	static inline container_a val(container_a const& other) noexcept
	{
		return container_a{ other };
	}

	static inline container_a ref(container_a& other) noexcept
	{
		return container_a(other, any_a<>::___reference_tag___{});
	}

	static inline container_a dup(container_a& other) noexcept
	{
		return container_a(other, any_a<>::___duplicate_tag___{});
	}

	inline container_a() = default;

	inline container_a(container_a& other, any_a<>::___reference_tag___) noexcept
		: collection_a< any_a<> , container_a<> , container_a<> >(other, any_a<>::___reference_tag___{})
	{}

	inline container_a(container_a& other, any_a<>::___duplicate_tag___) noexcept
		: collection_a< any_a<> , container_a<> , container_a<> >(other, any_a<>::___duplicate_tag___{})
	{}

	template <typename ___TTT___>
	explicit inline container_a(std_shared_ptr<___TTT___> const& handle) noexcept
		: collection_a< any_a<> , container_a<> , container_a<> >{ handle }
	{
		assert(!handle || std::dynamic_pointer_cast<___container_a_handle_base___>(handle));
	}

	template <typename ___TTT___>
	explicit inline container_a(std_shared_ptr<___TTT___>& handle, any_a<>::___reference_tag___) noexcept
		: collection_a< any_a<> , container_a<> , container_a<> >(handle, any_a<>::___reference_tag___{})
	{
		assert(!handle || std::dynamic_pointer_cast<___container_a_handle_base___>(handle));
	}

	template <typename ___TTT___, typename = typename std::enable_if_t<!std::is_base_of<container_a, std::decay_t<___TTT___>>::value>>
	explicit inline container_a(___TTT___ value) noexcept
		: collection_a< any_a<> , container_a<> , container_a<> >{ std_make_shared<___container_a_handle_final___<typename std::remove_reference_t<___TTT___>>>(std::move(value)) }
	{
		any_a<>::___handle___->___weak___(any_a<>::___handle___);
	}

	template <typename ___TTT___, typename... Args>
	explicit inline container_a(any_a<>::___variadic_tag___, ___TTT___*, Args&&... args)
		: collection_a< any_a<> , container_a<> , container_a<> >{ std_make_shared<___container_a_handle_final___<typename std::remove_reference_t<___TTT___>>>(any_a<>::___variadic_tag___{}, std::forward<Args>(args)...) }
	{
		any_a<>::___handle___->___weak___(any_a<>::___handle___);
	}

	template <typename ___TTT___>
	inline container_a& operator=(std_shared_ptr<___TTT___> const& handle) noexcept
	{
		assert(!handle || std::dynamic_pointer_cast<___container_a_handle_base___>(handle));
		any_a<>::___handle___ = handle;
		return *this;
	}

	template <typename ___TTT___, typename = typename std::enable_if_t<!std::is_base_of<container_a, std::decay_t<___TTT___>>::value>>
	inline container_a& operator=(___TTT___ value) noexcept
	{
		container_a temp{ std::move(value) };
		std::swap(temp.___handle___, any_a<>::___handle___);
		return *this;
	}

	static inline bool ___check___(any_a<> const& thing)
	{
		return bool{ std::dynamic_pointer_cast<___container_a_handle_base___>(thing.___handle___) };
	}

	static inline container_a ___cast___(any_a<> const& thing)
	{
		auto const ptr = std::dynamic_pointer_cast<___container_a_handle_base___>(thing.___handle___);
		if (ptr)
		{
			return container_a{ thing.___handle___ };
		}
		return container_a{ container_d<_1>{ thing } };
	}

	static inline container_a ___cast_ref___(any_a<>& thing)
	{
		auto const ptr = std::dynamic_pointer_cast<___container_a_handle_base___>(thing.___handle___);
		if (ptr)
		{
			return container_a(thing.___handle___, any_a<>::___reference_tag___{});
		}
		return container_a{ container_d<_1>(thing, any_a<>::___reference_tag___{}) };
	}

	static inline cat_a<> ___cat___();

	static inline unordered_herd_a<> ___cats___();

	static inline kind_a<> ___kind___();

	static inline unordered_herd_a<> ___kinds___();

	static inline unordered_shoal_a<> ___operations___();

	template <typename ___TTT___, typename... Args>
	static inline container_a create(Args&&... args)
	{
		return container_a(any_a<>::___variadic_tag___{}, static_cast<___TTT___*>(nullptr), std::forward<Args>(args)...);
	}
}; // class container_a

template <typename _1>
class container_d : public collection_d< any_a<> , container_a<> , container_a<> >
{
public:
	inline any_a<> unpack__(list_a<> const& arguments) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("unpack_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::unpack_ passed non-existent member");
		}
		return op.operate(*const_cast<container_d*>(this), arguments);
	}

	inline any_a<> unpack_(shoal_a<> const& shared_shoal) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("unpack_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::unpack_ passed non-existent member");
		}
		return cast<any_a<>>(variadic_operate(op, *const_cast<container_d*>(this), shared_shoal));
	}

	inline any_a<> unpack_unique__(list_a<> const& arguments) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("unpack_unique_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::unpack_unique_ passed non-existent member");
		}
		return op.operate(*const_cast<container_d*>(this), arguments);
	}

	inline any_a<> unpack_unique_(shoal_a<> const& shared_shoal, shoal_a<number_data_uint64_a<>, strange::any_a<>> & unique_shoal) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("unpack_unique_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::unpack_unique_ passed non-existent member");
		}
		return cast<any_a<>>(variadic_operate(op, *const_cast<container_d*>(this), shared_shoal, unique_shoal));
	}

	inline any_a < > unpack(shoal_a < > const & shared_shoal , any_a < > & unique_shoal ) const
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::unpack(shared_shoal, unique_shoal) not available"); }

	inline any_a<> close__(list_a<> const& arguments)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("close_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::close_ passed non-existent member");
		}
		return op.operate(*this, arguments);
	}

	inline any_a<> close_()
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("close_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::close_ passed non-existent member");
		}
		return cast<any_a<>>(variadic_operate(op, *this));
	}

	inline bool close()
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::close() not available"); }

	inline any_a<> closed__(list_a<> const& arguments) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("closed_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::closed_ passed non-existent member");
		}
		return op.operate(*const_cast<container_d*>(this), arguments);
	}

	inline any_a<> closed_() const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("closed_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::closed_ passed non-existent member");
		}
		return cast<any_a<>>(variadic_operate(op, *const_cast<container_d*>(this)));
	}

	inline bool closed() const
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::closed() not available"); }

	inline any_a<> reopen__(list_a<> const& arguments)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("reopen_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::reopen_ passed non-existent member");
		}
		return op.operate(*this, arguments);
	}

	inline any_a<> reopen_()
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("reopen_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::reopen_ passed non-existent member");
		}
		return cast<any_a<>>(variadic_operate(op, *this));
	}

	inline bool reopen()
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::reopen() not available"); }

	inline any_a<> from_json__(list_a<> const& arguments)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("from_json_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::from_json_ passed non-existent member");
		}
		return op.operate(*this, arguments);
	}

	inline container_a<> from_json_(lake_int8_a<> const& lake)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("from_json_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::from_json_ passed non-existent member");
		}
		return cast<container_a<>>(variadic_operate(op, *this, lake));
	}

	inline void from_json(std_string const & str )
	{ from_json_(lake_from_string(str)); }

	inline any_a<> to_json__(list_a<> const& arguments) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("to_json_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::to_json_ passed non-existent member");
		}
		return op.operate(*const_cast<container_d*>(this), arguments);
	}

	inline lake_int8_a<> to_json_() const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("to_json_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::to_json_ passed non-existent member");
		}
		return cast<lake_int8_a<>>(variadic_operate(op, *const_cast<container_d*>(this)));
	}

	inline std_string to_json() const
	{ return lake_to_string(to_json_()); }

	inline any_a<> from_binary__(list_a<> const& arguments)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("from_binary_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::from_binary_ passed non-existent member");
		}
		return op.operate(*this, arguments);
	}

	inline container_a<> from_binary_(lake_int8_a<> const& lake)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("from_binary_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::from_binary_ passed non-existent member");
		}
		return cast<container_a<>>(variadic_operate(op, *this, lake));
	}

	inline void from_binary(std_string const & str )
	{ from_binary_(lake_from_string(str)); }

	inline any_a<> to_binary__(list_a<> const& arguments) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("to_binary_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::to_binary_ passed non-existent member");
		}
		return op.operate(*const_cast<container_d*>(this), arguments);
	}

	inline lake_int8_a<> to_binary_() const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("to_binary_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::to_binary_ passed non-existent member");
		}
		return cast<lake_int8_a<>>(variadic_operate(op, *const_cast<container_d*>(this)));
	}

	inline std_string to_binary() const
	{ return lake_to_string(to_binary_()); }

	inline any_a<> from_null__(list_a<> const& arguments)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("from_null_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::from_null_ passed non-existent member");
		}
		return op.operate(*this, arguments);
	}

	inline container_a<> from_null_()
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("from_null_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::from_null_ passed non-existent member");
		}
		return cast<container_a<>>(variadic_operate(op, *this));
	}

	inline void from_null()
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::from_null() not available"); }

	inline any_a<> is_null__(list_a<> const& arguments) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("is_null_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::is_null_ passed non-existent member");
		}
		return op.operate(*const_cast<container_d*>(this), arguments);
	}

	inline any_a<> is_null_() const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("is_null_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::is_null_ passed non-existent member");
		}
		return cast<any_a<>>(variadic_operate(op, *const_cast<container_d*>(this)));
	}

	inline bool is_null() const
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::is_null() not available"); }

	inline any_a<> from_boolean__(list_a<> const& arguments)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("from_boolean_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::from_boolean_ passed non-existent member");
		}
		return op.operate(*this, arguments);
	}

	inline container_a<> from_boolean_(any_a<> const& boolean)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("from_boolean_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::from_boolean_ passed non-existent member");
		}
		return cast<container_a<>>(variadic_operate(op, *this, boolean));
	}

	inline void from_boolean(bool boolean )
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::from_boolean(boolean) not available"); }

	inline any_a<> is_boolean__(list_a<> const& arguments) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("is_boolean_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::is_boolean_ passed non-existent member");
		}
		return op.operate(*const_cast<container_d*>(this), arguments);
	}

	inline any_a<> is_boolean_() const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("is_boolean_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::is_boolean_ passed non-existent member");
		}
		return cast<any_a<>>(variadic_operate(op, *const_cast<container_d*>(this)));
	}

	inline bool is_boolean() const
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::is_boolean() not available"); }

	inline any_a<> to_boolean__(list_a<> const& arguments) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("to_boolean_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::to_boolean_ passed non-existent member");
		}
		return op.operate(*const_cast<container_d*>(this), arguments);
	}

	inline any_a<> to_boolean_() const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("to_boolean_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::to_boolean_ passed non-existent member");
		}
		return cast<any_a<>>(variadic_operate(op, *const_cast<container_d*>(this)));
	}

	inline bool to_boolean() const
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::to_boolean() not available"); }

	inline any_a<> from_number__(list_a<> const& arguments)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("from_number_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::from_number_ passed non-existent member");
		}
		return op.operate(*this, arguments);
	}

	inline container_a<> from_number_(number_a<> const& number)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("from_number_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::from_number_ passed non-existent member");
		}
		return cast<container_a<>>(variadic_operate(op, *this, number));
	}

	inline void from_number(number_a < > const & number )
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::from_number(number) not available"); }

	inline any_a<> is_number__(list_a<> const& arguments) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("is_number_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::is_number_ passed non-existent member");
		}
		return op.operate(*const_cast<container_d*>(this), arguments);
	}

	inline any_a<> is_number_() const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("is_number_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::is_number_ passed non-existent member");
		}
		return cast<any_a<>>(variadic_operate(op, *const_cast<container_d*>(this)));
	}

	inline bool is_number() const
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::is_number() not available"); }

	inline any_a<> to_number__(list_a<> const& arguments) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("to_number_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::to_number_ passed non-existent member");
		}
		return op.operate(*const_cast<container_d*>(this), arguments);
	}

	inline number_a<> to_number_() const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("to_number_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::to_number_ passed non-existent member");
		}
		return cast<number_a<>>(variadic_operate(op, *const_cast<container_d*>(this)));
	}

	inline any_a<> from_int_64__(list_a<> const& arguments)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("from_int_64_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::from_int_64_ passed non-existent member");
		}
		return op.operate(*this, arguments);
	}

	inline container_a<> from_int_64_(number_data_int64_a<> const& number)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("from_int_64_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::from_int_64_ passed non-existent member");
		}
		return cast<container_a<>>(variadic_operate(op, *this, number));
	}

	inline void from_int_64(int64_t number )
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::from_int_64(number) not available"); }

	inline any_a<> is_int_64__(list_a<> const& arguments) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("is_int_64_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::is_int_64_ passed non-existent member");
		}
		return op.operate(*const_cast<container_d*>(this), arguments);
	}

	inline any_a<> is_int_64_() const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("is_int_64_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::is_int_64_ passed non-existent member");
		}
		return cast<any_a<>>(variadic_operate(op, *const_cast<container_d*>(this)));
	}

	inline bool is_int_64() const
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::is_int_64() not available"); }

	inline any_a<> to_int_64__(list_a<> const& arguments) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("to_int_64_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::to_int_64_ passed non-existent member");
		}
		return op.operate(*const_cast<container_d*>(this), arguments);
	}

	inline number_data_int64_a<> to_int_64_() const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("to_int_64_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::to_int_64_ passed non-existent member");
		}
		return cast<number_data_int64_a<>>(variadic_operate(op, *const_cast<container_d*>(this)));
	}

	inline int64_t to_int_64() const
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::to_int_64() not available"); }

	inline any_a<> from_float_64__(list_a<> const& arguments)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("from_float_64_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::from_float_64_ passed non-existent member");
		}
		return op.operate(*this, arguments);
	}

	inline container_a<> from_float_64_(number_data_double_a<> const& number)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("from_float_64_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::from_float_64_ passed non-existent member");
		}
		return cast<container_a<>>(variadic_operate(op, *this, number));
	}

	inline void from_float_64(double number )
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::from_float_64(number) not available"); }

	inline any_a<> is_float_64__(list_a<> const& arguments) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("is_float_64_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::is_float_64_ passed non-existent member");
		}
		return op.operate(*const_cast<container_d*>(this), arguments);
	}

	inline any_a<> is_float_64_() const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("is_float_64_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::is_float_64_ passed non-existent member");
		}
		return cast<any_a<>>(variadic_operate(op, *const_cast<container_d*>(this)));
	}

	inline bool is_float_64() const
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::is_float_64() not available"); }

	inline any_a<> to_float_64__(list_a<> const& arguments) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("to_float_64_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::to_float_64_ passed non-existent member");
		}
		return op.operate(*const_cast<container_d*>(this), arguments);
	}

	inline number_data_double_a<> to_float_64_() const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("to_float_64_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::to_float_64_ passed non-existent member");
		}
		return cast<number_data_double_a<>>(variadic_operate(op, *const_cast<container_d*>(this)));
	}

	inline double to_float_64() const
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::to_float_64() not available"); }

	inline any_a<> from_lake__(list_a<> const& arguments)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("from_lake_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::from_lake_ passed non-existent member");
		}
		return op.operate(*this, arguments);
	}

	inline container_a<> from_lake_(lake_int8_a<> const& lake)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("from_lake_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::from_lake_ passed non-existent member");
		}
		return cast<container_a<>>(variadic_operate(op, *this, lake));
	}

	inline void from_lake(lake_int8_a < > const & lake )
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::from_lake(lake) not available"); }

	inline void from_string(std_string const & str )
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::from_string(str) not available"); }

	inline any_a<> is_lake__(list_a<> const& arguments) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("is_lake_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::is_lake_ passed non-existent member");
		}
		return op.operate(*const_cast<container_d*>(this), arguments);
	}

	inline any_a<> is_lake_() const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("is_lake_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::is_lake_ passed non-existent member");
		}
		return cast<any_a<>>(variadic_operate(op, *const_cast<container_d*>(this)));
	}

	inline bool is_lake() const
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::is_lake() not available"); }

	inline any_a<> to_lake__(list_a<> const& arguments) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("to_lake_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::to_lake_ passed non-existent member");
		}
		return op.operate(*const_cast<container_d*>(this), arguments);
	}

	inline lake_int8_a<> to_lake_() const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("to_lake_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::to_lake_ passed non-existent member");
		}
		return cast<lake_int8_a<>>(variadic_operate(op, *const_cast<container_d*>(this)));
	}

	inline std_string to_string() const
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::to_string() not available"); }

	inline any_a<> from_symbol__(list_a<> const& arguments)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("from_symbol_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::from_symbol_ passed non-existent member");
		}
		return op.operate(*this, arguments);
	}

	inline container_a<> from_symbol_(symbol_a<> const& symbol)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("from_symbol_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::from_symbol_ passed non-existent member");
		}
		return cast<container_a<>>(variadic_operate(op, *this, symbol));
	}

	inline void from_symbol(symbol_a < > const & symbol )
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::from_symbol(symbol) not available"); }

	inline any_a<> to_symbol__(list_a<> const& arguments) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("to_symbol_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::to_symbol_ passed non-existent member");
		}
		return op.operate(*const_cast<container_d*>(this), arguments);
	}

	inline symbol_a<> to_symbol_() const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("to_symbol_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::to_symbol_ passed non-existent member");
		}
		return cast<symbol_a<>>(variadic_operate(op, *const_cast<container_d*>(this)));
	}

	inline any_a<> make_inventory__(list_a<> const& arguments)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("make_inventory_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::make_inventory_ passed non-existent member");
		}
		return op.operate(*this, arguments);
	}

	inline container_a<> make_inventory_()
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("make_inventory_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::make_inventory_ passed non-existent member");
		}
		return cast<container_a<>>(variadic_operate(op, *this));
	}

	inline void make_inventory()
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::make_inventory() not available"); }

	inline any_a<> from_inventory__(list_a<> const& arguments)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("from_inventory_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::from_inventory_ passed non-existent member");
		}
		return op.operate(*this, arguments);
	}

	inline container_a<> from_inventory_(inventory_a<container_a<>> const& inventory)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("from_inventory_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::from_inventory_ passed non-existent member");
		}
		return cast<container_a<>>(variadic_operate(op, *this, inventory));
	}

	inline void from_inventory(inventory_a < container_a < > > const & inventory )
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::from_inventory(inventory) not available"); }

	inline any_a<> is_inventory__(list_a<> const& arguments) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("is_inventory_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::is_inventory_ passed non-existent member");
		}
		return op.operate(*const_cast<container_d*>(this), arguments);
	}

	inline any_a<> is_inventory_() const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("is_inventory_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::is_inventory_ passed non-existent member");
		}
		return cast<any_a<>>(variadic_operate(op, *const_cast<container_d*>(this)));
	}

	inline bool is_inventory() const
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::is_inventory() not available"); }

	inline any_a<> as_inventory__(list_a<> const& arguments) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("as_inventory_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::as_inventory_ passed non-existent member");
		}
		return op.operate(*const_cast<container_d*>(this), arguments);
	}

	inline any_a<> as_inventory_(inventory_a<container_a<>> & inventory) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("as_inventory_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::as_inventory_ passed non-existent member");
		}
		return cast<any_a<>>(variadic_operate(op, *const_cast<container_d*>(this), inventory));
	}

	inline void as_inventory(inventory_a < container_a < > > & inventory ) const
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::as_inventory(inventory) not available"); }

	inline any_a<> make_herd__(list_a<> const& arguments)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("make_herd_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::make_herd_ passed non-existent member");
		}
		return op.operate(*this, arguments);
	}

	inline container_a<> make_herd_()
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("make_herd_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::make_herd_ passed non-existent member");
		}
		return cast<container_a<>>(variadic_operate(op, *this));
	}

	inline void make_herd()
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::make_herd() not available"); }

	inline any_a<> from_herd__(list_a<> const& arguments)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("from_herd_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::from_herd_ passed non-existent member");
		}
		return op.operate(*this, arguments);
	}

	inline container_a<> from_herd_(herd_a<symbol_a<>> const& herd)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("from_herd_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::from_herd_ passed non-existent member");
		}
		return cast<container_a<>>(variadic_operate(op, *this, herd));
	}

	inline void from_herd(herd_a < symbol_a < > > const & herd )
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::from_herd(herd) not available"); }

	inline any_a<> is_herd__(list_a<> const& arguments) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("is_herd_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::is_herd_ passed non-existent member");
		}
		return op.operate(*const_cast<container_d*>(this), arguments);
	}

	inline any_a<> is_herd_() const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("is_herd_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::is_herd_ passed non-existent member");
		}
		return cast<any_a<>>(variadic_operate(op, *const_cast<container_d*>(this)));
	}

	inline bool is_herd() const
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::is_herd() not available"); }

	inline any_a<> as_herd__(list_a<> const& arguments) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("as_herd_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::as_herd_ passed non-existent member");
		}
		return op.operate(*const_cast<container_d*>(this), arguments);
	}

	inline any_a<> as_herd_(herd_a<symbol_a<>> & herd) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("as_herd_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::as_herd_ passed non-existent member");
		}
		return cast<any_a<>>(variadic_operate(op, *const_cast<container_d*>(this), herd));
	}

	inline void as_herd(herd_a < symbol_a < > > & herd ) const
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::as_herd(herd) not available"); }

	inline any_a<> make_shoal__(list_a<> const& arguments)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("make_shoal_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::make_shoal_ passed non-existent member");
		}
		return op.operate(*this, arguments);
	}

	inline container_a<> make_shoal_()
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("make_shoal_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::make_shoal_ passed non-existent member");
		}
		return cast<container_a<>>(variadic_operate(op, *this));
	}

	inline void make_shoal()
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::make_shoal() not available"); }

	inline any_a<> from_shoal__(list_a<> const& arguments)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("from_shoal_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::from_shoal_ passed non-existent member");
		}
		return op.operate(*this, arguments);
	}

	inline container_a<> from_shoal_(shoal_a<symbol_a<>, container_a<>> const& shoal)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("from_shoal_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::from_shoal_ passed non-existent member");
		}
		return cast<container_a<>>(variadic_operate(op, *this, shoal));
	}

	inline void from_shoal(shoal_a < symbol_a < > , container_a < > > const & shoal )
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::from_shoal(shoal) not available"); }

	inline any_a<> is_shoal__(list_a<> const& arguments) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("is_shoal_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::is_shoal_ passed non-existent member");
		}
		return op.operate(*const_cast<container_d*>(this), arguments);
	}

	inline any_a<> is_shoal_() const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("is_shoal_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::is_shoal_ passed non-existent member");
		}
		return cast<any_a<>>(variadic_operate(op, *const_cast<container_d*>(this)));
	}

	inline bool is_shoal() const
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::is_shoal() not available"); }

	inline any_a<> as_shoal__(list_a<> const& arguments) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("as_shoal_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::as_shoal_ passed non-existent member");
		}
		return op.operate(*const_cast<container_d*>(this), arguments);
	}

	inline any_a<> as_shoal_(shoal_a<symbol_a<>, container_a<>> & shoal) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("as_shoal_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::as_shoal_ passed non-existent member");
		}
		return cast<any_a<>>(variadic_operate(op, *const_cast<container_d*>(this), shoal));
	}

	inline void as_shoal(shoal_a < symbol_a < > , container_a < > > & shoal ) const
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::as_shoal(shoal) not available"); }

	inline any_a<> from_data__(list_a<> const& arguments)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("from_data_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::from_data_ passed non-existent member");
		}
		return op.operate(*this, arguments);
	}

	inline any_a<> from_data_(any_a<> const& data)
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("from_data_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::from_data_ passed non-existent member");
		}
		return cast<any_a<>>(variadic_operate(op, *this, data));
	}

	inline bool from_data(any_a < > const & data )
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::from_data(data) not available"); }

	inline any_a<> as_data__(list_a<> const& arguments) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("as_data_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::as_data_ passed non-existent member");
		}
		return op.operate(*const_cast<container_d*>(this), arguments);
	}

	inline any_a<> as_data_(any_a<> & data) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("as_data_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::as_data_ passed non-existent member");
		}
		return cast<any_a<>>(variadic_operate(op, *const_cast<container_d*>(this), data));
	}

	inline bool as_data(any_a < > & data ) const
	{ throw dis(__FILE__, __LINE__, "dynamic container_d::as_data(data) not available"); }

	inline any_a<> keys_begin__(list_a<> const& arguments) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("keys_begin_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::keys_begin_ passed non-existent member");
		}
		return op.operate(*const_cast<container_d*>(this), arguments);
	}

	inline bidirectional_extractor_a< any_a<> > keys_begin_() const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("keys_begin_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::keys_begin_ passed non-existent member");
		}
		return cast<bidirectional_extractor_a< any_a<> >>(variadic_operate(op, *const_cast<container_d*>(this)));
	}

	inline any_a<> keys_end__(list_a<> const& arguments) const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("keys_end_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::keys_end_ passed non-existent member");
		}
		return op.operate(*const_cast<container_d*>(this), arguments);
	}

	inline bidirectional_extractor_a< any_a<> > keys_end_() const
	{
		assert(any_a<>::___handle___);
		auto const op = any_a<>::operation("keys_end_");
		if (!op)
		{
			throw dis(__FILE__, __LINE__, "dynamic container_d::keys_end_ passed non-existent member");
		}
		return cast<bidirectional_extractor_a< any_a<> >>(variadic_operate(op, *const_cast<container_d*>(this)));
	}

	void ___weak___(any_a<>::___WEAK___ const& weak) const {}

	explicit container_d(any_a<> const& thing)
		: collection_d< any_a<> , container_a<> , container_a<> >{ thing }
	{}

	explicit container_d(any_a<>& thing, any_a<>::___reference_tag___)
		: collection_d< any_a<> , container_a<> , container_a<> >{ thing, any_a<>::___reference_tag___{} }
	{}

	explicit container_d(any_a<>& thing, any_a<>::___duplicate_tag___)
		: collection_d< any_a<> , container_a<> , container_a<> >{ thing, any_a<>::___duplicate_tag___{} }
	{}
};

} // namespace
